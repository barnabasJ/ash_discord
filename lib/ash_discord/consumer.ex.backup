defmodule AshDiscord.Consumer do
  @moduledoc """
  Enhanced Nostrum consumer that integrates AshDiscord command handling.

  This module provides a `using` macro that allows you to create Discord consumers
  with built-in AshDiscord command handling capabilities while maintaining the
  ability to extend and customize behavior.

  ## Basic Usage

      defmodule MyApp.DiscordConsumer do
        use AshDiscord.Consumer

        # Optionally override callbacks to extend behavior
        def handle_message_create(message) do
          # Custom message processing logic
          Logger.info("Custom message processing")
          :ok
        end

        def handle_ready(data) do
          # Custom ready event handling
          Logger.info("Bot ready with custom logic!")
          :ok
        end
      end

  ## Available Callbacks

  The following callbacks can be overridden to extend behavior:

  - `handle_message_create(message)` - Called for each MESSAGE_CREATE event
  - `handle_guild_create(guild)` - Called for each GUILD_CREATE event
  - `handle_ready(data)` - Called when the bot is ready
  - `handle_interaction_create(interaction)` - Called for INTERACTION_CREATE events
  - `handle_application_command(interaction)` - Called for slash commands specifically
  - `handle_guild_role_create(role)` - Called when a guild role is created
  - `handle_guild_role_update(role)` - Called when a guild role is updated
  - `handle_guild_role_delete(data)` - Called when a guild role is deleted
  - `handle_guild_member_add(guild_id, member)` - Called when a member joins a guild
  - `handle_guild_member_update(guild_id, member)` - Called when a guild member is updated
  - `handle_guild_member_remove(guild_id, member)` - Called when a member leaves a guild
  - `handle_unknown_event(event)` - Called for any other events

  All callbacks should return `:ok` or `{:error, reason}`.

  ## Built-in Features

  When you `use AshDiscord.Consumer`, you automatically get:

  - Automatic Discord command registration on bot ready
  - INTERACTION_CREATE event handling with routing to Ash actions
  - MESSAGE_CREATE event handling with message storage
  - Error handling and logging
  - Backward compatibility with existing message handling patterns

  ## Customization

  You can customize the behavior by implementing the optional callbacks:

      defmodule MyApp.DiscordConsumer do
        use AshDiscord.Consumer

        # Override to add custom message processing
        def handle_message_create(message) do
          if String.contains?(message.content, "special") do
            # Custom logic for special messages
            process_special_message(message)
          end
          :ok
        end

        # Override to add custom ready logic
        def handle_ready(data) do
          Logger.info("Custom ready logic executed")
          send_startup_notification()
          :ok
        end

        defp process_special_message(message), do: :ok
        defp send_startup_notification(), do: :ok
      end

  The base implementation will still handle Discord command registration and
  interaction routing automatically.
  """

  @doc """
  Callback for handling MESSAGE_CREATE events from Discord.

  Called whenever a message is created in a channel the bot can see.
  The default implementation stores the message in the Discord domain
  and processes it if the bot is mentioned or it's a direct message.

  ## Parameters

  - `message` - The Discord message struct from Nostrum

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_message_create(message :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling GUILD_CREATE events from Discord.

  Called when the bot joins a new guild or when guilds are loaded on startup.

  ## Parameters

  - `guild` - The Discord guild struct from Nostrum

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_guild_create(guild :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling GUILD_UPDATE events from Discord.

  Called when a guild's settings are updated (name, icon, description, etc.).

  ## Parameters

  - `guild` - The updated Discord guild struct from Nostrum

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_guild_update(guild :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling GUILD_DELETE events from Discord.

  Called when a guild becomes unavailable or when the bot is removed from a guild.

  ## Parameters

  - `data` - Guild delete data containing guild ID and unavailable flag

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_guild_delete(data :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling READY events from Discord.

  Called when the bot successfully connects to Discord and is ready to receive events.
  The default implementation registers Discord commands with the API.

  ## Parameters

  - `data` - The ready event data from Discord

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_ready(data :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling INTERACTION_CREATE events from Discord.

  Called for all interaction events (slash commands, buttons, select menus, etc.).
  The default implementation routes application commands to AshDiscord handlers.

  ## Parameters

  - `interaction` - The Discord interaction struct from Nostrum

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_interaction_create(interaction :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling application command interactions specifically.

  Called for slash command interactions after `handle_interaction_create/1`.
  The default implementation routes the command to the appropriate Ash action.

  ## Parameters

  - `interaction` - The Discord application command interaction struct

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_application_command(interaction :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling GUILD_ROLE_CREATE events from Discord.

  Called when a new role is created in a guild the bot has access to.

  ## Parameters

  - `role` - The Discord role struct from Nostrum

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_guild_role_create(role :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling GUILD_ROLE_UPDATE events from Discord.

  Called when a role is updated in a guild the bot has access to.

  ## Parameters

  - `role` - The updated Discord role struct from Nostrum

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_guild_role_update(role :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling GUILD_ROLE_DELETE events from Discord.

  Called when a role is deleted in a guild the bot has access to.

  ## Parameters

  - `data` - The role deletion data (contains role_id and guild_id)

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_guild_role_delete(data :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling GUILD_MEMBER_ADD events from Discord.

  Called when a new member joins a guild the bot has access to.

  ## Parameters

  - `member` - The Discord guild member struct from Nostrum

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_guild_member_add(guild_id :: integer(), member :: map()) ::
              :ok | {:error, any()}

  @doc """
  Callback for handling GUILD_MEMBER_UPDATE events from Discord.

  Called when a guild member is updated (roles, nickname, etc.).

  ## Parameters

  - `member` - The updated Discord guild member struct from Nostrum

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_guild_member_update(guild_id :: integer(), member :: map()) ::
              :ok | {:error, any()}

  @doc """
  Callback for handling GUILD_MEMBER_REMOVE events from Discord.

  Called when a member leaves a guild the bot has access to.

  ## Parameters

  - `data` - The member removal data (contains user and guild_id)

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_guild_member_remove(guild_id :: integer(), member :: map()) ::
              :ok | {:error, any()}

  @doc """
  Callback for handling CHANNEL_CREATE events from Discord.

  Called when a channel is created in a guild the bot can see.

  ## Parameters

  - `channel` - The Discord channel struct from Nostrum

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_channel_create(channel :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling CHANNEL_UPDATE events from Discord.

  Called when a channel is updated in a guild the bot can see.

  ## Parameters

  - `channel` - The Discord channel struct from Nostrum

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_channel_update(channel :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling CHANNEL_DELETE events from Discord.

  Called when a channel is deleted in a guild the bot can see.

  ## Parameters

  - `channel` - The Discord channel struct from Nostrum

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_channel_delete(channel :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling MESSAGE_UPDATE events from Discord.

  Called when a message is updated/edited in a channel the bot can see.

  ## Parameters

  - `message` - The updated Discord message struct from Nostrum

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_message_update(message :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling MESSAGE_DELETE events from Discord.

  Called when a message is deleted in a channel the bot can see.

  ## Parameters

  - `data` - The message delete data (contains message_id, channel_id, guild_id)

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_message_delete(data :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling MESSAGE_DELETE_BULK events from Discord.

  Called when multiple messages are deleted at once in a channel.

  ## Parameters

  - `data` - The bulk delete data (contains ids list, channel_id, guild_id)

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_message_delete_bulk(data :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling MESSAGE_REACTION_ADD events from Discord.

  Called when a reaction is added to a message in a channel the bot can see.

  ## Parameters

  - `data` - The reaction add data (contains user_id, message_id, channel_id, guild_id, emoji)

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_message_reaction_add(data :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling MESSAGE_REACTION_REMOVE events from Discord.

  Called when a reaction is removed from a message in a channel the bot can see.

  ## Parameters

  - `data` - The reaction remove data (contains user_id, message_id, channel_id, guild_id, emoji)

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_message_reaction_remove(data :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling MESSAGE_REACTION_REMOVE_ALL events from Discord.

  Called when all reactions are removed from a message in a channel the bot can see.

  ## Parameters

  - `data` - The reaction remove all data (contains message_id, channel_id, guild_id)

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_message_reaction_remove_all(data :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling VOICE_STATE_UPDATE events from Discord.

  Called when a user's voice state changes (joins/leaves voice channel, mutes, etc.).

  ## Parameters

  - `voice_state` - The Discord voice state struct from Nostrum

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_voice_state_update(voice_state :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling TYPING_START events from Discord.

  Called when a user starts typing in a channel.

  ## Parameters

  - `typing_data` - The Discord typing event data from Nostrum

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_typing_start(typing_data :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling INVITE_CREATE events from Discord.

  Called when an invite is created in a guild the bot can see.

  ## Parameters

  - `invite` - The Discord invite struct from Nostrum

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_invite_create(invite :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling INVITE_DELETE events from Discord.

  Called when an invite is deleted in a guild the bot can see.

  ## Parameters

  - `invite_data` - The Discord invite deletion data from Nostrum

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_invite_delete(invite_data :: map()) :: :ok | {:error, any()}

  @doc """
  Callback for handling unknown or unhandled Discord events.

  Called for any Discord event that doesn't have a specific handler.
  The default implementation logs the event and ignores it.

  ## Parameters

  - `event` - The complete Discord event tuple `{event_type, data, ws_state}`

  ## Returns

  Should return `:ok` on success or `{:error, reason}` on failure.
  """
  @callback handle_unknown_event(event :: tuple()) :: :ok | {:error, any()}

  @doc """
  Callback for creating users from Discord interaction data.

  This callback allows consumers to specify how Discord users should be created
  or resolved when processing interactions. The default implementation returns nil.

  ## Parameters

  - `discord_user` - The Discord user struct from the interaction

  ## Returns

  Should return a user struct, `{:ok, user}`, `{:error, reason}`, or `nil`.
  """
  @callback create_user_from_discord(discord_user :: map()) :: any() | {:ok, any()} | {:error, any()} | nil

  # Make all callbacks optional with default implementations
  @optional_callbacks [
    handle_message_create: 1,
    handle_message_update: 1,
    handle_message_delete: 1,
    handle_message_delete_bulk: 1,
    handle_message_reaction_add: 1,
    handle_message_reaction_remove: 1,
    handle_message_reaction_remove_all: 1,
    handle_guild_create: 1,
    handle_guild_update: 1,
    handle_guild_delete: 1,
    handle_ready: 1,
    handle_interaction_create: 1,
    handle_application_command: 1,
    handle_guild_role_create: 1,
    handle_guild_role_update: 1,
    handle_guild_role_delete: 1,
    handle_guild_member_add: 2,
    handle_guild_member_update: 2,
    handle_guild_member_remove: 2,
    handle_channel_create: 1,
    handle_channel_update: 1,
    handle_channel_delete: 1,
    handle_voice_state_update: 1,
    handle_typing_start: 1,
    handle_invite_create: 1,
    handle_invite_delete: 1,
    handle_unknown_event: 1,
    create_user_from_discord: 1
  ]

  def collect_commands(domains) do
    Enum.flat_map(domains, fn domain ->
      AshDiscord.Info.discord_commands(domain)
    end)
  end

  def to_discord_command(command) do
    %{
      name: Atom.to_string(command.name),
      description: command.description,
      type: discord_command_type(command.type),
      options: Enum.sort_by(Enum.map(command.options, &to_discord_option/1), & &1.required, :desc)
    }
  end

  def to_discord_option(option) do
    base_option = %{
      name: Atom.to_string(option.name),
      description: option.description,
      type: discord_option_type(option.type),
      required: option.required
    }

    if option.choices do
      Map.put(base_option, :choices, option.choices)
    else
      base_option
    end
  end

  defp discord_command_type(:chat_input), do: 1
  defp discord_command_type(:user), do: 2
  defp discord_command_type(:message), do: 3

  defp discord_option_type(:string), do: 3
  defp discord_option_type(:integer), do: 4
  defp discord_option_type(:boolean), do: 5
  defp discord_option_type(:user), do: 6
  defp discord_option_type(:channel), do: 7
  defp discord_option_type(:role), do: 8
  defp discord_option_type(:mentionable), do: 9
  defp discord_option_type(:number), do: 10
  defp discord_option_type(:attachment), do: 11

  # DSL Extension functionality integrated directly
  use Spark.Dsl.Extension,
    sections: [AshDiscord.Dsl.Consumer.ash_discord_consumer()]

  @doc false
  defmacro __using__(opts) do
    extension_module = __MODULE__  # Capture AshDiscord.Consumer at compile-time
    domains = Keyword.get(opts, :domains, [])
    command_filter = Keyword.get(opts, :command_filter, nil)

    quote bind_quoted: [
      extension_module: extension_module,
      domains: domains, 
      command_filter: command_filter
    ] do
      @behaviour AshDiscord.Consumer

      use Nostrum.Consumer
      use Spark.Dsl, default_extensions: [{extension_module, []}]

      require Logger

      @ash_discord_domains domains
      @ash_discord_commands AshDiscord.Consumer.collect_commands(@ash_discord_domains)
      @ash_discord_command_filter command_filter

      @doc "Returns the configured domains for this consumer"
      def domains, do: @ash_discord_domains

      @doc "Returns the configured command filter for this consumer"
      def command_filter, do: @ash_discord_command_filter

      @doc "Finds a command by name from the compile-time command list"
      def find_command(command_name) do
        Enum.find(@ash_discord_commands, fn cmd -> cmd.name == command_name end)
      end

      def handle_message_create(message), do: :ok
      def handle_message_update(message), do: :ok
      def handle_message_delete(data), do: :ok
      def handle_message_delete_bulk(data), do: :ok
      def handle_message_reaction_add(data), do: :ok
      def handle_message_reaction_remove(data), do: :ok
      def handle_message_reaction_remove_all(data), do: :ok
      def handle_guild_create(guild), do: :ok
      def handle_guild_update(guild), do: :ok
      def handle_guild_delete(data), do: :ok
      def handle_ready(data), do: :ok

      def handle_interaction_create(interaction) do
        process_discord_interaction(interaction)
      end

      def handle_application_command(interaction), do: :ok
      def handle_guild_role_create(role), do: :ok
      def handle_guild_role_update(role), do: :ok
      def handle_guild_role_delete(data), do: :ok
      def handle_guild_member_add(guild_id, member), do: :ok
      def handle_guild_member_update(guild_id, member), do: :ok
      def handle_guild_member_remove(guild_id, member), do: :ok
      def handle_channel_create(channel), do: :ok
      def handle_channel_update(channel), do: :ok
      def handle_channel_delete(channel), do: :ok
      def handle_voice_state_update(voice_state), do: :ok
      def handle_typing_start(typing_data), do: :ok
      def handle_invite_create(invite), do: :ok
      def handle_invite_delete(invite_data), do: :ok
      def handle_unknown_event(event), do: :ok
      def create_user_from_discord(_discord_user), do: nil

      # Default implementations for command filtering - can be overridden
      def command_allowed_for_interaction?(interaction, command) do
        filter = command_filter()

        if filter do
          guild = extract_guild_context(interaction)
          filters = if is_list(filter), do: filter, else: [filter]
          AshDiscord.CommandFilter.command_allowed_by_chain?(command, guild, filters)
        else
          true
        end
      end

      def extract_guild_context(interaction) do
        # Basic guild context - library users can override this
        %{
          id: Map.get(interaction, :guild_id, 0),
          interaction: interaction
        }
      end

      defoverridable handle_message_create: 1,
                     handle_message_update: 1,
                     handle_message_delete: 1,
                     handle_message_delete_bulk: 1,
                     handle_message_reaction_add: 1,
                     handle_message_reaction_remove: 1,
                     handle_message_reaction_remove_all: 1,
                     handle_guild_create: 1,
                     handle_guild_update: 1,
                     handle_guild_delete: 1,
                     handle_ready: 1,
                     handle_interaction_create: 1,
                     handle_application_command: 1,
                     handle_guild_role_create: 1,
                     handle_guild_role_update: 1,
                     handle_guild_role_delete: 1,
                     handle_guild_member_add: 2,
                     handle_guild_member_update: 2,
                     handle_guild_member_remove: 2,
                     handle_channel_create: 1,
                     handle_channel_update: 1,
                     handle_channel_delete: 1,
                     handle_voice_state_update: 1,
                     handle_typing_start: 1,
                     handle_invite_create: 1,
                     handle_invite_delete: 1,
                     handle_unknown_event: 1,
                     create_user_from_discord: 1,
                     command_allowed_for_interaction?: 2,
                     extract_guild_context: 1

      def handle_event({:MESSAGE_CREATE, message, _ws_state}) do
        Logger.debug("Received Discord message: #{inspect(message)}")

        handle_message_create(message)

        if should_process_message?(message) do
          Logger.info(
            "Processing message from user #{message.author.id} in channel #{message.channel_id}"
          )

          try do
            process_discord_message(message)
            Logger.info("Successfully processed Discord message")
            :ok
          rescue
            error ->
              Logger.error("Failed to process Discord message: #{inspect(error)}")
              {:error, error}
          end
        else
          Logger.debug("Ignoring message (not for bot)")
          :ok
        end
      end

      def handle_event({:INTERACTION_CREATE, interaction, _ws_state}) do
        Logger.debug("Received Discord interaction: #{inspect(interaction)}")

        handle_interaction_create(interaction)

        case interaction.type do
          2 ->
            handle_application_command(interaction)
            handle_ash_discord_command(interaction)

          _ ->
            Logger.debug("Ignoring interaction type: #{interaction.type}")
            :ok
        end
      end

      def handle_event({:GUILD_CREATE, guild, _ws_state}) do
        Logger.info("Connected to Discord server: #{guild.name} (ID: #{guild.id})")
        handle_guild_create(guild)
      end

      def handle_event({:GUILD_UPDATE, guild, _ws_state}) do
        Logger.debug("Guild updated: #{guild.name} (ID: #{guild.id})")
        handle_guild_update(guild)
      end

      def handle_event({:GUILD_DELETE, data, _ws_state}) do
        Logger.debug("Guild delete event: #{data.id}, unavailable: #{data.unavailable}")
        handle_guild_delete(data)
      end

      def handle_event({:READY, data, _ws_state}) do
        Logger.info(
          "Discord bot is ready! Logged in as: #{data.user.username}##{data.user.discriminator}"
        )

        register_discord_commands()

        handle_ready(data)
      end

      def handle_event({:GUILD_ROLE_CREATE, role, _ws_state}) do
        Logger.debug("Guild role created: #{role.name} in guild #{role.guild_id}")
        handle_guild_role_create(role)
      end

      def handle_event({:GUILD_ROLE_UPDATE, role, _ws_state}) do
        Logger.debug("Guild role updated: #{role.name} in guild #{role.guild_id}")
        handle_guild_role_update(role)
      end

      def handle_event({:GUILD_ROLE_DELETE, data, _ws_state}) do
        Logger.debug("Guild role deleted: #{data.role_id} in guild #{data.guild_id}")
        handle_guild_role_delete(data)
      end

      def handle_event({:GUILD_MEMBER_ADD, {guild_id, member}, _ws_state}) do
        Logger.debug("Guild member added: #{member.user_id} to guild #{guild_id}")
        handle_guild_member_add(guild_id, member)
      end

      def handle_event({:GUILD_MEMBER_UPDATE, {guild_id, member}, _ws_state}) do
        Logger.debug("Guild member updated: #{member.user_id} in guild #{guild_id}")
        handle_guild_member_update(guild_id, member)
      end

      def handle_event({:GUILD_MEMBER_REMOVE, {guild_id, member}, _ws_state}) do
        Logger.debug("Guild member removed: #{member.user_id} from guild #{guild_id}")
        handle_guild_member_remove(guild_id, member)
      end

      def handle_event({:CHANNEL_CREATE, channel, _ws_state}) do
        Logger.debug("Channel created: #{channel.name} in guild #{channel.guild_id}")
        handle_channel_create(channel)
      end

      def handle_event({:CHANNEL_UPDATE, channel, _ws_state}) do
        Logger.debug("Channel updated: #{channel.name} in guild #{channel.guild_id}")
        handle_channel_update(channel)
      end

      def handle_event({:CHANNEL_DELETE, channel, _ws_state}) do
        Logger.debug("Channel deleted: #{channel.id} in guild #{channel.guild_id}")
        handle_channel_delete(channel)
      end

      def handle_event({:MESSAGE_UPDATE, {old_message, message}, _ws_state}) do
        Logger.debug("Message updated: #{message.id} in channel #{message.channel_id}")
        handle_message_update(message)
      end

      def handle_event({:MESSAGE_DELETE, data, _ws_state}) do
        Logger.debug("Message deleted: #{data.id} in channel #{data.channel_id}")
        handle_message_delete(data)
      end

      def handle_event({:MESSAGE_DELETE_BULK, data, _ws_state}) do
        Logger.debug(
          "Bulk message delete: #{length(data.ids)} messages in channel #{data.channel_id}"
        )

        handle_message_delete_bulk(data)
      end

      def handle_event({:MESSAGE_REACTION_ADD, data, _ws_state}) do
        Logger.debug("Reaction added: #{data.emoji.name} to message #{data.message_id}")
        handle_message_reaction_add(data)
      end

      def handle_event({:MESSAGE_REACTION_REMOVE, data, _ws_state}) do
        Logger.debug("Reaction removed: #{data.emoji.name} from message #{data.message_id}")
        handle_message_reaction_remove(data)
      end

      def handle_event({:MESSAGE_REACTION_REMOVE_ALL, data, _ws_state}) do
        Logger.debug("All reactions removed from message #{data.message_id}")
        handle_message_reaction_remove_all(data)
      end

      def handle_event({:VOICE_STATE_UPDATE, voice_state, _ws_state}) do
        Logger.debug("Voice state updated for user #{voice_state.user_id}")
        handle_voice_state_update(voice_state)
      end

      def handle_event({:TYPING_START, typing_data, _ws_state}) do
        Logger.debug(
          "User #{typing_data.user_id} started typing in channel #{typing_data.channel_id}"
        )

        handle_typing_start(typing_data)
      end

      def handle_event({:INVITE_CREATE, invite, _ws_state}) do
        Logger.debug("Invite created: #{invite.code}")
        handle_invite_create(invite)
      end

      def handle_event({:INVITE_DELETE, invite_data, _ws_state}) do
        Logger.debug("Invite deleted: #{invite_data.code}")
        handle_invite_delete(invite_data)
      end

      def handle_event(event) do
        Logger.debug("Received unknown Discord event: #{inspect(event)}")
        handle_unknown_event(event)
      end

      defp handle_ash_discord_command(interaction) do
        command_name = String.to_existing_atom(interaction.data.name)

        Logger.info("Processing slash command: #{command_name} from user #{interaction.user.id}")

        case find_command(command_name) do
          nil ->
            Logger.error("Unknown command: #{command_name}")
            respond_with_error(interaction, "Unknown command")

          command ->
            # Apply command filtering based on guild context
            if command_allowed_for_interaction?(interaction, command) do
              user_creator = fn discord_user -> create_user_from_discord(discord_user) end
              AshDiscord.InteractionRouter.route_interaction(interaction, command,
                user_creator: user_creator
              )
            else
              Logger.warn("Command #{command_name} filtered for guild #{interaction.guild_id}")
              respond_with_error(interaction, "This command is not available in this server")
            end
        end
      end


      defp register_discord_commands do
        Logger.info(
          "AshDiscord: Registering #{length(@ash_discord_commands)} commands with Discord"
        )

        discord_commands =
          Enum.map(
            @ash_discord_commands,
            &AshDiscord.Consumer.to_discord_command/1
          )

        # Register globally by default - library users can override this behavior
        result = Nostrum.Api.ApplicationCommand.bulk_overwrite_global_commands(discord_commands)

        case result do
          {:ok, _commands} ->
            Logger.info("Successfully registered Discord commands globally")

          {:error, error} ->
            Logger.error("Failed to register Discord commands: #{inspect(error)}")
        end
      end

      defp respond_with_error(interaction, message) do
        response = %{
          type: 4,
          data: %{
            content: message,
            flags: 64
          }
        }

        Nostrum.Api.Interaction.create_response(interaction.id, interaction.token, response)
      end

      defp should_process_message?(message) do
        if message.author.bot == true do
          false
        else
          message.guild_id == nil || bot_mentioned?(message)
        end
      end

      defp bot_mentioned?(message) do
        case Nostrum.Cache.Me.get() do
          %Nostrum.Struct.User{} = bot_user ->
            Enum.any?(message.mentions, fn user -> user.id == bot_user.id end)

          _error ->
            false
        end
      end

      defp process_discord_message(message) do
        Logger.debug("Processing Discord message: #{message.content}")
        :ok
      end

      defp process_discord_interaction(interaction) do
        Logger.debug("Processing Discord interaction: #{interaction.id}")

        # Note: Library users will need to implement their own interaction processing
        # In the original Steward implementation, this creates interaction records
        Logger.info("Successfully processed Discord interaction")
        :ok
      end
    end
  end
end
